package learnopengl;

public class Math {

    //we'll use org.joml javax.vecmath for all of this, but just to understand the maths behind things:

    //Vectors:
    //pretty much everything we already covered in school

    //NEW: Matrices
    //rectangular array of numbers, symbols and/or mathematical expressions
    //each individual is called an element
    //each element has to indices (y,x / i,j)
    //a 2x3 (=dimension) matrix would look like this:
    //  1  2  3
    //  4  5  6
    //the value 4 would be located at 2,1 (2nd row, 1st column)

    //addition and subtraction:
    //only defined for matrices of the same dimensions

    //for a 2x2 matrix:
    // 1  2     +   5  6  =  1+5  2+6  =  6  8
    // 3  4         7  8     3+7  4+8     10 12
    //same goes for subtraction

    //scalar products:
    //a matrix-scalar product multiplies each element by the scalar

    // 2 * 1  2 = 2  4
    //     3  4   6  8

    //Matrix-matrix multiplication:
    //only possible if the number of columns on A is equal to the number of rows on B
    //not commutative -> A*B != B*A

    //example: 2x2

    //  A       B
    //1  2  *  5  6  =  1*5+2*7  1*6+2*8  =  19  22
    //3  4     7  8     3*5+4*7  3*6+4*8     43  50

    //combination of normal multiplication and addition using the A's rows with B's columns
    //first: upper row of A, then a column of B

    //first row of A -> resulting value ends up in the first row of the result matrix
    //first column of B -> resulting value ends up in the first column of the result matrix

    //result matrix has the dimensions of (n,m)
    //n = number of rows on A
    //m = number of columns on B

    //Matrix-Vector multiplication:

    //vectors are basically nx1 matrices

    //used for 2D/3D transformations
    //transforms vectors

    //identity matrix:
    //OpenGL often uses 4x4 matrices
    //most vectors are 4-component vectors
    //the identity matrix is an NxN matrix which has only 0s except the diagonal elements

    //example:
    //1  0  0  0
    //0  1  0  0
    //0  0  1  0
    //0  0  0  1

    //leaves vectors unchanged in multiplication
    //starting point for generating other transformation matrices

    //Scaling:
    //multiplying vector coordinates with scaling variables

    //example:
    //vec2 v = vec2(3,2)
    //vec2 s = v * (0.5,2) = vec2(1.5,4)
    //non-uniform scale (not the same scaling factor for each axis)
    //uniform scale: scaling factor is equal for each axis

    //transformation matrix for scaling:

    //S_1  0    0    0     x     S_1*x
    //0    S_2  0    0  *  y  =  S_2*y
    //0    0    S_3  0     z     S_3*z
    //0    0    0    1     1     1

    //Translation:
    //adding another vector on top the original vector -> moving a vector

    //translation-vector: (T_x, T_y, T_z)
    //translation-matrix:

    //1  0  0  T_x   x   x+T_x
    //0  1  0  T_y * y = y+T_y
    //0  0  1  T_z   z   z+T_z
    //0  0  0  0     1   1

    //wouldn't be possible with a 3x3 matrix

    //w component of a vector = homogeneous coordinate
    //4D to 3D vector: divide each 3D coordinate by the w coordinate
    //w = 0 -> direction vector, can't be translated

    //translation-matrix makes objects movable

    //Rotation:
    //rotations are clockwise
    //specified with an angle and rotation axes

    //rotation around the x-axis:
    //1  0    0     0   x   x
    //0  cos  -sin  0 * y = cos*y-sin*z
    //0  sin  cos   0   z   sin*y+cos*z
    //0  0    0     1   1   1

    //rotation around the y-axis:
    //cos   0  sin  0   x   cos*x+sin*z
    //0     1  0    0 * y = y
    //-sin  0  cos  0   z   -sin*x+cos*z
    //0     0  0    1   1   1

    //rotation around the z-axis:
    //cos  -sin  0  0   x   cos*x-sin*y
    //sin  cos   0  0 * y = sin*x+cos*y
    //0    0     1  0   z   z
    //0    0     0  1   1   1

    //we could combine all 3 axes by first rotating around the x-axis, then y, then z
    //this will cause something called gimbal lock (https://youtu.be/zc8b2Jo7mno)
    //to lower the chance of this happening, we could use a rotation-matrix that uses an axis, that is not one of the three we always use (x=(1,0,0), y=(0,1,0), z=(0,0,1))
    //a=(R_x, R_y, R_z) which is a unit vector (length = 1)
    //the rotation matrix can be found at https://learnopengl.com/Getting-started/Transformations
    //however, this still does not completely prevent gimbal lock from happening, but quaternions will (https://youtu.be/kHFwysRM2ps)
    //there's a java implementation of quaternions in the org.joml javax.vecmath library, so we'll use these

    //combining matrices
    //can be generated by multiplying a translation-matrix with a scaling-matrix

    public static void main(String[] args) {
        /*//vector translation
        Vector4f vec1 = new Vector4f(1, 0, 0, 1);
        Matrix4f trans1 = new Matrix4f();
        trans1.setIdentity();
        trans1.setTranslation(new Vector3f(1, 1, 0));
        trans1.transform(vec1);

        //scale and rotate
        Matrix4f trans2 = new Matrix4f();
        trans2.setIdentity();
        trans2.setRotation(new Quat4f(0, 0, 1, (float) java.lang.Math.toRadians(90.0f)));
        trans2.setScale(0.5f);*/

    }

}
